version: "3.8"

x-sql-env: &sql_env
  DB: postgres12
  DB_PORT: 5432
  POSTGRES_SEEDS: postgresql
  POSTGRES_USER: temporal
  POSTGRES_PWD: temporal

networks:
  temporal-net:

volumes:
  pgdata:

services:
  # Mock OIDC IdP for local SSO tests
  oauth-mock:
    image: ghcr.io/navikt/mock-oauth2-server:2.1.10
    container_name: oauth-mock
    environment:
      SERVER_PORT: "8080"
      JSON_CONFIG_PATH: /config/mock-oauth-config.json
      # Override the hostname in URLs returned by the server
      OVERRIDE_HOSTNAME: "localhost:8081"
    volumes:
      - ./oauth-mock-config.json:/config/mock-oauth-config.json:ro
    ports: [ "8081:8080" ]
    networks: [ temporal-net ]

  postgresql:
    image: postgres:16
    container_name: temporal-postgresql
    environment:
      POSTGRES_USER: temporal
      POSTGRES_PASSWORD: temporal
    ports: ["5432:5432"]
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U temporal"]
      interval: 5s
      timeout: 3s
      retries: 20
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks: [temporal-net]

  # Core services (point to INTERNAL frontend)
  temporal-history:
    image: temporalio/auto-setup:${TEMPORAL_VERSION:-1.28.1}
    container_name: temporal-history
    depends_on:
      postgresql: { condition: service_healthy }
    environment:
      <<: *sql_env
      SERVICES: history
      TEMPORAL_ADDRESS: temporal-frontend-internal:7233
      TEMPORAL_ENVIRONMENT: docker
      TEMPORAL_CONFIG_DIR: /config
    volumes:
      - ./config/docker.yaml:/config/docker.yaml:ro
    networks: [temporal-net]
    restart: no

  temporal-matching:
    image: temporalio/server:${TEMPORAL_VERSION:-1.28.1}
    container_name: temporal-matching
    depends_on:
      temporal-history: { condition: service_started }
    environment:
      <<: *sql_env
      SERVICES: matching
      TEMPORAL_ADDRESS: temporal-frontend-internal:7233
      TEMPORAL_ENVIRONMENT: docker
      TEMPORAL_CONFIG_DIR: /config
    volumes:
      - ./config/docker.yaml:/config/docker.yaml:ro
    networks: [temporal-net]
    restart: no

  temporal-worker:
    image: temporalio/server:${TEMPORAL_VERSION:-1.28.1}
    container_name: temporal-worker
    depends_on:
      temporal-frontend-internal: { condition: service_started }
    environment:
      <<: *sql_env
      SERVICES: worker
      # (!) internal FE port
      PUBLIC_FRONTEND_ADDRESS: temporal-frontend-internal:7233
      TEMPORAL_ENVIRONMENT: docker
      TEMPORAL_CONFIG_DIR: /config
      # Disable the worker scanners that require auth
      TEMPORAL_HISTORY_SCANNER_ENABLED: "false"
      TEMPORAL_TASKQUEUE_SCANNER_ENABLED: "false"
    volumes:
      - ./config/docker.yaml:/config/docker.yaml:ro
    networks: [temporal-net]
    profiles: ["with-worker"]  # Optional - start only when explicitly requested
    restart: no

  # UI (OIDC) -> forwards Authorization to EXTERNAL frontend
  temporal-ui:
    image: temporalio/ui:${TEMPORAL_UI_VERSION:-2.35.0}
    container_name: temporal-ui
    depends_on:
      temporal-frontend-external: { condition: service_started }
      oauth-mock: { condition: service_started }
    environment:
      TEMPORAL_ADDRESS: temporal-frontend-external:7232
      TEMPORAL_AUTH_ENABLED: "true"
      TEMPORAL_AUTH_TYPE: oidc
      # UI connects to oauth-mock via Docker network
      # But oauth-mock will return localhost:8081 URLs for the browser
      TEMPORAL_AUTH_PROVIDER_URL: http://oauth-mock:8080/default
      TEMPORAL_AUTH_CLIENT_ID: temporal-ui
      TEMPORAL_AUTH_CLIENT_SECRET: temporal-ui-secret
      TEMPORAL_AUTH_CALLBACK_URL: http://localhost:8080/auth/sso/callback
      TEMPORAL_AUTH_SCOPES: openid,profile,email
      # (!) Forward the bearer token to your external frontend
      TEMPORAL_FORWARD_HEADERS: authorization
    ports: ["8080:8080"]
    networks: [temporal-net]

  # Optional: CLI/admin tools
  temporal-admin-tools:
    image: temporalio/admin-tools:1.28.1-tctl-1.18.4-cli-1.4.1
    container_name: temporal-admin-tools
    depends_on:
      temporal-frontend-external: { condition: service_started }
    environment:
      TEMPORAL_ADDRESS: temporal-frontend-external:7232
    stdin_open: true
    tty: true
    networks: [temporal-net]
    profiles: ["admin"]

  # ---------- EXTERNAL FRONTEND (custom) ----------
  # Exposed to UI/SDK/CLI; has your ClaimMapper for API-key/JWT.
  temporal-frontend-external:
    image: temporal-frontend-apikey:${TEMPORAL_VERSION:-1.28.1}
    container_name: temporal-frontend-external
    depends_on:
      temporal-matching: { condition: service_started }
    environment:
      <<: *sql_env
      SERVICES: frontend
      # (!) the correct env
      TEMPORAL_ADDRESS: temporal-frontend-internal:7233
      TEMPORAL_ENVIRONMENT: docker
      TEMPORAL_CONFIG_DIR: /config
      # (!)
      # Example API keys for local testing:
      TEMPORAL_API_KEYS: "admin-key:admin:*;test-key:writer:default"
      # (!) No need to add OAuth ENVs from temporal-ui, it will be used from /config/docker.yaml global.authorization.jwtKeyProvider
    ports: ["7232:7232"]   # expose only the external frontend
    volumes:
      - ./config/docker.yaml:/config/docker.yaml:ro
    networks: [temporal-net]
    restart: no

  # ---------- INTERNAL FRONTEND (stock) ----------
  # Used by History/Matching/Worker. No custom auth.
  temporal-frontend-internal:
    image: temporalio/server:${TEMPORAL_VERSION:-1.28.1}
    container_name: temporal-frontend-internal
    depends_on:
      temporal-matching: { condition: service_started }
    environment:
      <<: *sql_env
      SERVICES: internal-frontend
      # (!) the correct env
      TEMPORAL_ENVIRONMENT: docker
      TEMPORAL_CONFIG_DIR: /config
      # Required for internal-frontend config section to be included
      USE_INTERNAL_FRONTEND: "true"
    volumes:
      - ./config/docker.yaml:/config/docker.yaml:ro
    networks: [temporal-net]
    restart: no
